gather(year, gdp, -country) %>%
mutate(year = as.numeric(year)) %>%
filter(!is.na(country)) %>%
filter(!is.na(gdp)) %>%
filter(year > 1990)
installed.packages()
library(tidyverse)
library(tidyverse)
install.packages('Amelia')
install.packages('broom')
install.packages("broom")
library(broom)
library(tidyverse)
library(Amelia)
# This sets the seed that ’sample’ uses and ensures we will
#get the same random numbers if we repeated it
set.seed(1234)
x <- c(sample(1:10, 7, TRUE), rep(NA, 3))
x
## we ca't just do a direct mean of the entire vector because R doesn't know what to do with the null values
sum(x)
## we can however just remove the null values during the calculation to get a mean of the existing values
mean(x, na.rm = TRUE)
## to estimate the standard error we use the standard deviation devided by the square root of the sample size
sd(x, na.rm = TRUE)/sqrt(sum(!is.na(x)))
## here we also use the not is.na
!is.na(x)
# This takes the elements of x that are not missing and adds on
# 3 randomly chosen x values to replace the missing values. It
# does this 5 times and saves the result as ’imp’
imp <- replicate(5, c(x[!is.na(x)], sample(x[!is.na(x)], 3, TRUE)), simplify = FALSE)
imp
#mean of those means
qbar <- mean(sapply(imp,mean))
#This calculates the within variance, denoted Vbar above
within.var <- (1/5)*sum((sapply(imp,sd)/sqrt(10))^2)
#This calculates the between variance, denoted B above
between.var <- (1/4)*sum((sapply(imp,mean)-qbar)^2)
#This calculates T
bigt <- within.var + (1+(1/5))*between.var
#This calculates the standard error of T
sebigt <- sqrt(bigt)
lapply(1:3, function(x) x^2)
#This calculates q bar, by using sapply to take
#a mean of each list element of ’imp’ and then taking the
#mean of those means
?qbar
#This calculates q bar, by using sapply to take
#a mean of each list element of ’imp’ and then taking the
#mean of those means
?sapply
# This takes the elements of x that are not missing and adds on
# 3 randomly chosen x values to replace the missing values. It
# does this 5 times and saves the result as ’imp’
listOf5Elementes <- replicate(5, c(x[!is.na(x)], sample(x[!is.na(x)], 3, TRUE)), simplify = FALSE)
listOf5Elementes
# This takes the elements of x that are not missing and adds on
# 3 randomly chosen x values to replace the missing values. It
# does this 5 times and saves the result as ’imp’
FiveLisstOf5Elementes <- replicate(5, c(x[!is.na(x)], sample(x[!is.na(x)], 3, TRUE)), simplify = FALSE)
FiveListsOf5Elementes
# This takes the elements of x that are not missing and adds on
# 3 randomly chosen x values to replace the missing values. It
# does this 5 times and saves the result as ’imp’
FiveListsOf5Elementes <- replicate(5, c(x[!is.na(x)], sample(x[!is.na(x)], 3, TRUE)), simplify = FALSE)
FiveListsOf5Elementes
FiveListsOf5Elementes
# This takes the elements of x that are not missing and adds on
# 3 randomly chosen x values to replace the missing values. It
# does this 5 times and saves the result as ’imp’
FiveListsOf5Elementes <- replicate(5, c(x[!is.na(x)], sample(x[!is.na(x)], 3, TRUE)), simplify = FALSE)
x <- c(sample(1:10, 7, TRUE), rep(NA, 3))
# This takes the elements of x that are not missing and adds on
# 3 randomly chosen x values to replace the missing values. It
# does this 5 times and saves the result as ’imp’
FiveListsOf5Elementes <- replicate(5, c(x[!is.na(x)], sample(x[!is.na(x)], 3, TRUE)), simplify = FALSE)
FiveListsOf5Elementes
qbar <- mean(sapply(FiveLisstOf5Elementes,mean))
qbar <- mean(sapply(FiveLisstOf5Elementes,mean))
qbar <- mean(sapply(FiveListsOf5Elementes,mean))
# This takes the elements of x that are not missing and adds on
# 3 randomly chosen x values to replace the missing values. It
# does this 5 times and saves the result as ’imp’
CollectionOf5Elementes <- replicate(5, c(x[!is.na(x)], sample(x[!is.na(x)], 3, TRUE)), simplify = FALSE)
CollectionOf5Elementes
## sapply - applies a function over each element of a vector
totalMean <- mean(sapply(CollectionOf5Elementes,mean))
View(FiveListsOf5Elementes)
## sapply - applies a function over each element of a vector
totalMean <- mean(sapply(CollectionOf5Elementes,mean))
varianceInsideTheCollection <- (1/5)*sum((sapply(CollectionOf5Elementes,sd)/sqrt(10))^2)
#This calculates the within variance
## calculation of the variance from all between all the inserted new values
varianceIOfTheCollection <- (1/5)*sum((sapply(CollectionOf5Elementes,sd)/sqrt(10))^2)
betweenVarianceOfTheCollection <- (1/4)*sum((sapply(imp,mean)-qbar)^2)
betweenVarianceOfTheCollection <- (1/4)*sum((sapply(CollectionOf5Elementes,mean)-qbar)^2)
betweenVarianceOfTheCollection <- (1/4)*sum((sapply(CollectionOf5Elementes,mean)-qbar)^2)
#This calculates the within variance
## Within-Group Variation The total variation in the individual values in each group and their group mean
withinVarianceIOfTheCollection <- (1/5)*sum((sapply(CollectionOf5Elementes,sd)/sqrt(10))^2)
## finds the square of each element in the vector
lapply(1:3, function(x) x^2)
## finds the square of each element in the vector
teste = lapply(1:3, function(x) x^2)
teste
n = c(2, 3, 5)
s = c("aa", "bb", "cc", "dd", "ee")
b = c(TRUE, FALSE, TRUE, FALSE, FALSE)
x = list(n, s, b, 3) # x contains copies of n, s, b
x
listOfNumbers = c(2, 3, 5)
listOfStrings = c("aa", "bb", "cc", "dd", "ee")
listOfBooleans = c(TRUE, FALSE, TRUE, FALSE, FALSE)
ColletionOfLists = list(n, s, b, 3) # x contains copies of n, s, b
CollectionOfLists = list(n, s, b, 3) # x contains copies of n, s, b
CollectionOfLists[2]
meanCoefficientMatrix <- CollectionOfLists %>% #begin with our imputed data list object
sapply(mean) %>% #pipe it into sapply and take the mean of each element
matrix() # pipe it into a matrix
CollectionOfLists
meanCoefficientMatrix <- CollectionOfLists %>% #begin with our imputed data list object
sapply(mean) %>% #pipe it into sapply and take the mean of each element
matrix()
meanCoefficientMatrix = CollectionOfLists %>% #begin with our imputed data list object
sapply(mean) %>% #pipe it into sapply and take the mean of each element
matrix() # pipe it into a matrix
meanCoefficientMatrix = CollectionOf5Elementes %>% #begin with our imputed data list object
sapply(mean) %>% #pipe it into sapply and take the mean of each element
matrix() # pipe it into a matrix
meanCoefficientMatrix
standardErrorMatrix <- CollectionOf5Elementes %>% #begin with our imputed data list object
sapply(sd)%>% #pipe it into sapply and take the standard deviation of each element
'/'(sqrt(10)) %>% # divide by the square root of 10 to get standard errors
matrix() # make it a matrix
standardErrorMatrix
myMatrixCollection(meanCoefficientMatrix, standardErrorMatrix)
mi.meld(meanCoefficientMatrix, standardErrorMatrix)
?mi.meld
africa
data("africa")
data(africa)
data(africa)
summary(africa)
# This fits a linear model were GDP is predicted using civil liberties and trade
regr_model <- lm(gdp_pc ~ civlib + trade, data = africa)
summary(regr_model)
summary(regressionModel)
# This fits a linear model were GDP is predicted using civil liberties and trade
regressionModel <- lm(gdp_pc ~ civlib + trade, data = africa)
summary(regressionModel)
Call:
lm(formula = gdp_pc ~ civlib + trade, data = africa)
lm(formula = gdp_pc ~ civlib + trade, data = africa)
regressionModel <- lm(gdp_pc ~ civlib + trade, data = africa)
summary(regressionModel)
Call:
lm(formula = gdp_pc ~ civlib + trade, data = africa)
regressionModel <- lm(gdp_pc ~ civlib + trade, data = africa)
summary(regressionModel)
Call:
lm(formula = gdp_pc ~ civlib + trade, data = africa)
lm(formula = gdp_pc ~ civlib + trade, data = africa)
lm(formula = gdp_pc ~ civlib + trade, data = africa)
# This fits a linear model were GDP is predicted using civil liberties and trade
regressionModel = lm(gdp_pc ~ civlib + trade, data = africa)
summary(regressionModel)
?summary
missing_var_summary()
?missing_var_summary()
install.packages('naniar')
missing_var_summary(regressionModel)
miss_var_summary
miss_var_summary(regressionModel)
library('naniar')
miss_var_summary(regressionModel)
miss_var_summary()
regressionModel
miss_var_summary(regressionModel)
regressionModel
miss_case_summary(regressionModel)
miss_var_table(regressionModel)
miss_var_span(regressionModel)
miss_var_span(africa)
africa
miss_var_span(africa)
vis_miss(africa)
?amelia
?amelia
#Impute missing values
imp_amelia <- amelia(x = africa, #use the africa data
m = 5, # repeat 5 times
idvars="country", #This specifies country as an ID variable, not to be imputed.
logs = "gdp_pc", #variables that require log transform
p2s = 1) #Output type
viss_miss(africa)
vis_miss(imp_africa)
vis_miss(imp_amelia)
#Impute missing values
imp_amelia <- amelia(x = africa, #use the africa data
m = 5, # repeat 5 times
idvars="country", #This specifies country as an ID variable, not to be imputed.
logs = "gdp_pc", #variables that require log transform
p2s = 1) #Output type
vis_miss(imp_amelia)
missmap(imp_amelia)
## graphs/maps and lets your see missing values
?missmap
#Impute missing values
ameliaPassedDataSet <- amelia(x = africa, #use the africa data
m = 5, # repeat 5 times
idvars="country", #This specifies country as an ID variable, not to be imputed.
logs = "gdp_pc", #variables that require log transform
p2s = 1) #Output type
missmap(ameliaPassedDataSet)
head(ameliaPassedDataSet$imputations$imp1)
setwd("C:/AppliedDataScienceAndStatistics/Applied-Data-Science-and-Statistics/Term1/WorkingWithData/week3")
missmap(ameliaPassedDataSet)
head(ameliaPassedDataSet$imputations$imp1)
missmap(ameliaPassedDataSet)
regr_model <- lm(gdp_pc ~ civlib + trade, data = imp_amelia$imputations$imp1)
summary(regr_model)
lmAmeliaOut <- lapply(imp_amelia$imputations, function(i) lm(gdp_pc ~ civlib + trade,
data = i))
lmAmeliaOut
averageAmeliaOutputOfImputedValues <- lapply(imp_amelia$imputations, function(i) lm(gdp_pc ~ civlib + trade,
data = i))
averageAmeliaOutputOfImputedValues
coefecientAmelia <- averageAmeliaOutputOfImputedValues %>% # We begin with our list of models
sapply(coef) %>% # we use sapply to extract coefficients from each model
t()
# This creates a function to extract a standard error from a model
#This helps us as we can just call this function in our lapply
my_SE_extractor <- function(model) {summary(model)$coef[,"Std. Error"]}
ses.amelia <- lm.amelia.out %>% # we begin with our list of linear models again
sapply(my_SE_extractor) %>% #we apply our standard error extracting function
t() #we take a transpose of the matrix (just making rows into columns and vice versa)
ses.amelia <- averageAmeliaOutputOfImputedValues %>% # we begin with our list of linear models again
sapply(my_SE_extractor) %>% #we apply our standard error extracting function
t() #we take a transpose of the matrix (just making rows into columns and vice versa)
mi.meld(coefecientAmelia, ses.amelia)
iris
ggplot(data=iris, aes(x=Sepal.Length,y=Sepal.Width)) +
geom_point(colour='black') + # Specifying a scatter plot
geom_smooth(method="lm") + # creates de "correlation" ## worst correlation ever
labs(x="Sepal Length", y="Sepal Width") # Axes labels
ggplot(iris, aes(x=Sepal.Length,y=Sepal.Width)) +
geom_point(colour='black') + # Specifying a scatter plot
geom_smooth(method="lm") + # creates de "correlation" ## worst correlation ever
labs(x="Sepal Length", y="Sepal Width") # Axes labels
#Now we are ready to use mi.meld
?mi.meld
## it combines multiple results from multiple imputed(randomly filled up) data sets
mi.meld(coefecientAmelia, ses.amelia)
?set.seed
set.seed(facundes)
set.seed('facundes')
set.seed(20221012)
regressionModel1 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp1)
regressionModel2 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp2)
regressionModel3 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp3)
regressionModel4 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp4)
regressionModel5 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp5)
regressionModel1
regressionModel5 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp5)
regressionModel1
regressionModel2
regressionModel1
regressionModel1$coefficients
regressionModel1$coefficients$civlib
regressionModel1$coefficients
regressionModel1
regressionModel1$coefficients
ameliaPassedDataSet$imputations$imp1
regressionModel1$coefficients
regressionModel1$coefficients
str_extract(regressionModel1$coefficients)
str_extract(regressionModel1$coefficients, '-')
str_extract(regressionModel1$coefficients, '')
str_extract(regressionModel1$coefficients, '-676')
str_extract(regressionModel1$coefficients, '-')
str_extract(regressionModel1$coefficients, '')
regressionModel1$coefficients
teste = substr(regressionModel1$coefficients, 1,3)
#teste =
substr(regressionModel1$coefficients, 1,3)
regressionModel1$coefficients
#teste =
substr(regressionModel1$coefficients, 1,20)
teste =
substr(regressionModel1$coefficients, 1,20)
teste
teste$2
teste[2]
civilianLibertiesCoefficient1 = coefficientRegressionModel1[2]
coefficientRegressionModel1 = substr(regressionModel1$coefficients, 1,20)
civilianLibertiesCoefficient1 = coefficientRegressionModel1[2]
civilianLibertiesCoefficient1
civilianLibertiesCoefficient1 = as.numeric(civilianLibertiesCoefficient1)
civilianLibertiesCoefficient1
coefficientRegressionModel2 = substr(regressionModel2$coefficients, 1,20)
civilianLibertiesCoefficient2 = coefficientRegressionModel2[2]
civilianLibertiesCoefficient2 = as.numeric(civilianLibertiesCoefficient2)
civilianLibertiesCoefficient2
ggplot(data=iris, aes(x=Sepal.Length,y=Sepal.Width)) +
geom_point(colour='black') + # Specifying a scatter plot
geom_smooth(method="lm") + # creates de "correlation" ## worst correlation ever
labs(xlab, ylab,ggtitle ) # Axes labels
ggplot(data=iris, aes(x=Sepal.Length,y=Sepal.Width)) +
geom_point(colour='black') + # Specifying a scatter plot
geom_smooth(method="lm") + # creates de "correlation" ## worst correlation ever
# Axes labels
xlab('S width')+
ylab('S Length')+
ggtitle('good title')
ggplot(data=iris, aes(x=Sepal.Length,y=Sepal.Width)) +
geom_point(aes(color = Species)) + # Specifying a scatter plot
scale_color_manual(values=c("#999999", "#E69F00", "#56B4E9")) +
geom_smooth(method="lm") + # creates de "correlation" ## worst correlation ever
labs(xlab, ylab,ggtitle ) + # Axes labels
facet_grid(. ~ Species) # Facet split by columns
coefficientRegressionModel3 = substr(regressionModel3$coefficients, 1,20)
civilianLibertiesCoefficient3 = coefficientRegressionModel3[2]
civilianLibertiesCoefficient3 = as.numeric(civilianLibertiesCoefficient3)
coefficientRegressionModel4 = substr(regressionModel4$coefficients, 1,20)
civilianLibertiesCoefficient4 = coefficientRegressionModel4[2]
civilianLibertiesCoefficient4 = as.numeric(civilianLibertiesCoefficient4)
coefficientRegressionModel5 = substr(regressionModel5$coefficients, 1,20)
civilianLibertiesCoefficient5 = coefficientRegressionModel5[2]
civilianLibertiesCoefficient5 = as.numeric(civilianLibertiesCoefficient5)
?mean()
mean(civilianLibertiesCoefficient1,civilianLibertiesCoefficient2)
mean(civilianLibertiesCoefficient1,civilianLibertiesCoefficient2,civilianLibertiesCoefficient3,
civilianLibertiesCoefficient4,civilianLibertiesCoefficient5)
mean(c(civilianLibertiesCoefficient1,civilianLibertiesCoefficient2,civilianLibertiesCoefficient3,
civilianLibertiesCoefficient4,civilianLibertiesCoefficient5))
mean(c(civilianLibertiesCoefficient1,civilianLibertiesCoefficient2,civilianLibertiesCoefficient3,
civilianLibertiesCoefficient4))
mi.meld(coefecientAmelia, ses.amelia)
avereageCoefficientOfCivilianLiberties
avereageCoefficientOfCivilianLiberties = mean(c(civilianLibertiesCoefficient1,civilianLibertiesCoefficient2,
civilianLibertiesCoefficient3,civilianLibertiesCoefficient4,civilianLibertiesCoefficient5))
avereageCoefficientOfCivilianLiberties
coefficientRegressionModel5[2]
coefficientRegressionModel4[2
coefficientRegressionModel4[2]
coefficientRegressionModel4[2]
mi.meld(coefecientAmelia, ses.amelia)
?mean
set.seed(20221012)
regressionModel1 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp1)
regressionModel2 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp2)
regressionModel3 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp3)
regressionModel4 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp4)
regressionModel5 <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp5)
coefficientRegressionModel1 = substr(regressionModel1$coefficients, 1,20)
civilianLibertiesCoefficient1 = coefficientRegressionModel1[2]
civilianLibertiesCoefficient1 = as.numeric(civilianLibertiesCoefficient1)
coefficientRegressionModel2 = substr(regressionModel2$coefficients, 1,20)
civilianLibertiesCoefficient2 = coefficientRegressionModel2[2]
civilianLibertiesCoefficient2 = as.numeric(civilianLibertiesCoefficient2)
coefficientRegressionModel3 = substr(regressionModel3$coefficients, 1,20)
civilianLibertiesCoefficient3 = coefficientRegressionModel3[2]
civilianLibertiesCoefficient3 = as.numeric(civilianLibertiesCoefficient3)
coefficientRegressionModel4 = substr(regressionModel4$coefficients, 1,20)
civilianLibertiesCoefficient4 = coefficientRegressionModel4[2]
civilianLibertiesCoefficient4 = as.numeric(civilianLibertiesCoefficient4)
coefficientRegressionModel5 = substr(regressionModel5$coefficients, 1,20)
civilianLibertiesCoefficient5 = coefficientRegressionModel5[2]
civilianLibertiesCoefficient5 = as.numeric(civilianLibertiesCoefficient5)
avereageCoefficientOfCivilianLiberties = mean(c(civilianLibertiesCoefficient1,civilianLibertiesCoefficient2,
civilianLibertiesCoefficient3,civilianLibertiesCoefficient4,civilianLibertiesCoefficient5))
avereageCoefficientOfCivilianLiberties
mi.meld(coefecientAmelia, ses.amelia)
## we can run a regression model on each imputed data set
regr_model <- lm(gdp_pc ~ civlib + trade, data = ameliaPassedDataSet$imputations$imp1)
summary(regr_model)
## but we can also simply do this for each data set at the same time using lappy
averageAmeliaOutputOfImputedValues = lapply(ameliaPassedDataSet$imputations, function(i) lm(gdp_pc ~ civlib + trade,
data = i))
averageAmeliaOutputOfImputedValues
##Averaging across the results is a little bit trickier than our earlier example because we have to extract
## the coefficients and standard errors from each model, format them in a particular way, and then feed that
## structure into the mi.meld function. The ‘mi.meld’ function applies Rubin’s rules to the summary statistics
## we have extracted
##The ‘lapply’ function takes the list of fitted models contained in ‘averageAmeliaOutputOfImputedValuest’ and
## applies a function to each element of that list.
##The function takes a ‘summary’ of each model output, and extracts the coefficients from that summary (using ‘coef’)
## It extracts the first or second column depending on whether we want coefficients or standard errors extracted
coefecientAmelia <- averageAmeliaOutputOfImputedValues %>% # We begin with our list of models
sapply(coef) %>% # we use sapply to extract coefficients from each model
t()
# This creates a function to extract a standard error from a model
#This helps us as we can just call this function in our lapply
my_SE_extractor <- function(model) {summary(model)$coef[,"Std. Error"]}
ses.amelia <- averageAmeliaOutputOfImputedValues %>% # we begin with our list of linear models again
sapply(my_SE_extractor) %>% #we apply our standard error extracting function
t() #we take a transpose of the matrix (just making rows into columns and vice versa)
#Now we are ready to use mi.meld
?mi.meld
## mi.meld() - it combines multiple results from multiple imputed(randomly filled up) data sets
mi.meld(coefecientAmelia, ses.amelia)
avereageCoefficientOfCivilianLiberties
mi.meld(coefecientAmelia, ses.amelia)
?mean
standardErrorAmelia <- averageAmeliaOutputOfImputedValues %>% # we begin with our list of linear models again
sapply(my_SE_extractor) %>% #we apply our standard error extracting function
t() #we take a transpose of the matrix (just making rows into columns and vice versa)
## mi.meld() - it combines multiple results from multiple imputed(randomly filled up) data sets
mi.meld(coefecientAmelia, standardErrorAmelia)
mi.meld(coefecientAmelia, ses.amelia)
coefficientRegressionModel1
regressionModel1
regressionModel1
ameliaPassedDataSet$imputations$imp1
nrow(ameliaPassedDataSet$imputations$imp1)
m = nrow(ameliaPassedDataSet$imputations$imp1)
Q = 1/m * sum(ameliaPassedDataSet$imputations$imp1$civlib)
Q
ameliaPassedDataSet$imputations$imp1$civlib
B = 1/(m-1) * (sum(ameliaPassedDataSet$imputations$imp1$civlib) - Q)^2
B
ameliaPassedDataSet$imputations$imp1
summmary(ameliaPassedDataSet$imputations$imp1)
summary(ameliaPassedDataSet$imputations$imp1)
ameliaPassedDataSet$imputations$imp1$civlib
mean(ameliaPassedDataSet$imputations$imp1$civlib)
nrow(ameliaPassedDataSet$imputations$imp1$civlib))
nrow(ameliaPassedDataSet$imputations$imp1$civlib)
nrow(ameliaPassedDataSet$imputations$imp1)
ameliaPassedDataSet$imputations$imp1
ameliaPassedDataSet$imputations$imp1$civlib[2]
ameliaPassedDataSet$imputations$imp1$civlib[1]
ameliaPassedDataSet$imputations$imp1$civlib[3]
ameliaPassedDataSet$imputations$imp1$civlib
totalXi = totalXi + aux
totalXi = 0
for (i in 1:m) {
aux = x - ameliaPassedDataSet$imputations$imp1$civlib[i]
totalXi = totalXi + aux
print(totalXi)
}
i=0
for (i in 1:m) {
aux = x - ameliaPassedDataSet$imputations$imp1$civlib[i]
totalXi = totalXi + aux
print(totalXi)
}
x
x
mean(ameliaPassedDataSet$imputations$imp1$civlib)
x = mean(ameliaPassedDataSet$imputations$imp1$civlib)
x
xpto = mean(ameliaPassedDataSet$imputations$imp1$civlib)
xpto
for (i in 1:m) {
aux = xpto - ameliaPassedDataSet$imputations$imp1$civlib[i]
totalXi = totalXi + aux
print(totalXi)
}
totalXi
QForImputed1 = 1/m * sum(ameliaPassedDataSet$imputations$imp1$civlib)
QForImputed2 = 1/m * sum(ameliaPassedDataSet$imputations$imp2$civlib)
QForImputed3 = 1/m * sum(ameliaPassedDataSet$imputations$imp3$civlib)
QForImputed4 = 1/m * sum(ameliaPassedDataSet$imputations$imp4$civlib)
QForImputed5 = 1/m * sum(ameliaPassedDataSet$imputations$imp5$civlib)
ameliaPassedDataSet$imputations$imp2$civlib
ameliaPassedDataSet$imputations$imp4$civlib
ameliaPassedDataSet$imputations$imp5$civlib
naniar(africa)
missmap(ameliaPassedDataSet)
xpto
xpto = mean(ameliaPassedDataSet$imputations$imp1$civlib)
totalXi
topHalfOfσ = totalXi^2
topHalfOfσ
(topHalfOfσ/(m-1))
σ = (topHalfOfσ/(m-1))
(σ / sqrt(m))
SE = (σ / sqrt(m))
sum(SE)^2
?sd
ameliaPassedDataSet$imputations$imp1$civlib
sd(ameliaPassedDataSet$imputations$imp1$civlib)
standardDeviation = sd(ameliaPassedDataSet$imputations$imp1$civlib)
SE = (σ / sqrt(m))
V = 1/m + (sum(SE)^2)
SE
standardDeviation = sd(ameliaPassedDataSet$imputations$imp1$civlib)
SE = (σ / sqrt(m))
V = 1/m + (sum(SE)^2)
V = 1/m + (sum(SE)^2)
V
?se
T = V + ((1 + (1/m))*B)
T = V + ((1 + (1/m))*B)
SET = sqrt(T)
SET
mi.meld(meanCoefficientMatrix, standardErrorMatrix)
?mi.meld
SET = sqrt(T)
SET
SET
mi.meld(meanCoefficientMatrix, standardErrorMatrix)
T
SET = sqrt(T)
SET
sd(ameliaPassedDataSet$imputations$imp1)
ameliaPassedDataSet$imputations$imp1
meanCoefficientMatrix
standardErrorMatrix
CollectionOf5Elementes
?mi.meld
